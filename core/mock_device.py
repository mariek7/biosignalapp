"""
Mock BITalino device for testing without hardware AUTO-GENERATED BY LLM.
Generates signals that mimic real device output.
"""
import numpy as np
import time
import logging


class MockBITalino:
    """Drop-in replacement for BITalino class that generates simulated data."""
    
    def __init__(self, macAddress=None, timeout=10):
        self.socket = "MOCK"  # Indicate mock mode
        self.analogChannels = []
        self.number_bytes = None
        self.macAddress = macAddress
        self.serial = False
        self.mock_sample_count = 0
        self.mock_rate = 1000  # Default sampling rate
        self.started = False
        logging.info(f"MockBITalino initialized - simulated device at {macAddress}")

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def find(self, serial=False):
        """Return mock device list."""
        if serial:
            return ["/dev/mock0"]
        else:
            return [("00:00:00:00:00:00", "MockBITalino")]

    def open(self, macAddress=None, SamplingRate=1000, timeout: float = 5.0):
        """Simulate opening connection."""
        if macAddress:
            self.macAddress = macAddress
        self.mock_rate = SamplingRate
        logging.info(f"MockBITalino opened: {macAddress} @ {SamplingRate} Hz")
        return True

    def start(self, analogChannels=None):
        """Start simulated acquisition."""
        if analogChannels is None:
            analogChannels = [0, 1, 2, 3, 4, 5]
        self.analogChannels = list(dict.fromkeys(analogChannels))
        if len(self.analogChannels) == 0 or len(self.analogChannels) > 6:
            raise ValueError("Invalid analog channels")
        
        self.started = True
        self.mock_sample_count = 0
        logging.info(f"MockBITalino started: channels A{self.analogChannels}")
        return True

    def stop(self):
        """Stop simulated acquisition."""
        self.started = False
        logging.info("MockBITalino stopped")
        return True

    def close(self):
        """Close mock connection."""
        if self.started:
            self.stop()
        self.socket = None
        logging.info("MockBITalino closed")
        return True

    def write(self, data=0, retries: int = 1, backoff: float = 0.1):
        """Simulate writing to device."""
        return True

    def read(self, nSamples=100, timeout: float = 5.0):
        """
        Generate realistic simulated EEG data.
        Returns same format as real BITalino: (5 + nChannels) x nSamples array.
        """
        if not self.started:
            raise RuntimeError("Device not started. Call start() first.")
        
        if not self.analogChannels:
            raise ValueError("Analog channels must be specified before reading.")

        nChannels = len(self.analogChannels)
        # Match real device format: [seq, D0, D1, D2, D3, A0, A1, ...]
        dataAcquired = np.zeros((5 + nChannels, nSamples))

        for sample_idx in range(nSamples):
            t = self.mock_sample_count / self.mock_rate
            self.mock_sample_count += 1

            # Row 0: Sequence number (0-15)
            dataAcquired[0, sample_idx] = self.mock_sample_count % 16

            # Rows 1-4: Digital channels (D0-D3)
            # Simulate button presses, periodic signals
            dataAcquired[1, sample_idx] = 1 if (self.mock_sample_count % 200) < 50 else 0  # D0: periodic pulse
            dataAcquired[2, sample_idx] = 1 if np.random.random() < 0.1 else 0  # D1: random events
            dataAcquired[3, sample_idx] = 0  # D2: off
            dataAcquired[4, sample_idx] = 0  # D3: off

            # Rows 5+: Analog channels (A0-A5)
            for ch_offset, ch in enumerate(self.analogChannels):
                signal = self._generate_eeg_channel(t, ch)
                # BITalino ADC is 10-bit: 0-1023
                value = int(512 + signal)
                value = max(0, min(1023, value))
                dataAcquired[5 + ch_offset, sample_idx] = value

        return dataAcquired

    def _generate_eeg_channel(self, t, channel):
        """
        Generate realistic EEG signal for a specific channel.
        Returns value in range roughly -100 to +100 (will be scaled to 10-bit).
        """
        # Different frequency patterns for each channel
        patterns = {
            0: self._alpha_wave,    # A0: Alpha (8-12 Hz)
            1: self._beta_wave,     # A1: Beta (12-30 Hz)
            2: self._theta_wave,    # A2: Theta (4-8 Hz)
            3: self._delta_wave,    # A3: Delta (0.5-4 Hz)
            4: self._mixed_wave,    # A4: Mixed
            5: self._gamma_wave,    # A5: Gamma (30-100 Hz)
        }
        
        generator = patterns.get(channel, self._mixed_wave)
        signal = generator(t)
        
        # Add baseline noise
        noise = np.random.normal(0, 3)
        
        # Occasional artifacts (eye blinks, muscle movement)
        if np.random.random() < 0.01:  # 1% chance
            artifact = np.random.normal(0, 50)
        else:
            artifact = 0
        
        return signal + noise + artifact

    def _alpha_wave(self, t):
        """Alpha rhythm: 8-12 Hz, relaxed wakefulness."""
        return 40 * np.sin(2 * np.pi * 10 * t) + 20 * np.sin(2 * np.pi * 9 * t)

    def _beta_wave(self, t):
        """Beta rhythm: 12-30 Hz, active thinking."""
        return 25 * np.sin(2 * np.pi * 18 * t) + 15 * np.sin(2 * np.pi * 22 * t)

    def _theta_wave(self, t):
        """Theta rhythm: 4-8 Hz, drowsiness."""
        return 50 * np.sin(2 * np.pi * 6 * t) + 25 * np.sin(2 * np.pi * 7 * t)

    def _delta_wave(self, t):
        """Delta rhythm: 0.5-4 Hz, deep sleep."""
        return 60 * np.sin(2 * np.pi * 2 * t) + 30 * np.sin(2 * np.pi * 3 * t)

    def _gamma_wave(self, t):
        """Gamma rhythm: 30-100 Hz, cognitive processing."""
        return 15 * np.sin(2 * np.pi * 40 * t) + 10 * np.sin(2 * np.pi * 60 * t)

    def _mixed_wave(self, t):
        """Mixed frequency content."""
        return (30 * np.sin(2 * np.pi * 10 * t) + 
                20 * np.sin(2 * np.pi * 5 * t) + 
                15 * np.sin(2 * np.pi * 15 * t))

    def decode(self, data, nAnalog=None):
        """Not used in mock mode, but included for compatibility."""
        raise NotImplementedError("decode() not needed for MockBITalino")
